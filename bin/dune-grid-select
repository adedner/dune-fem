#!/usr/bin/env python

import argparse
import json
import os
import re
import sys
import Tkinter

def list_to_string ( values ) :
    string = ""
    for value in values :
        string += str( value ) + ", "
    return string[:-2]

def variables ( string ) :
    variables=[]
    while True :
        match = re.search( "\$\(([a-zA-Z]+)\)", string )
        if not match :
            return variables
        if match.group( 1 ) not in variables:
            variables += [ match.group( 1 ) ]
        string = string[match.end():]

def replace ( string, parameters, defaults, translations ) :
    while True :
        match = re.search( "\$\(([a-zA-Z]+)\)", string )
        if not match :
            break
        option = match.group( 1 )
        if option in parameters :
            value = parameters[ option ]
        elif option in defaults :
            value = replace( defaults[ option ], parameters, defaults, translations )
        else :
            print "Error: No value specified for parameter " + option + "."
            sys.exit( 1 )
        if option in translations :
            if value in translations[ option ] :
                value = translations[ option ][ value ]
            else :
                print "Error: Unable to translate value '" + value + "' for option '" + option + "'."
                print "       Valid values are: " + list_to_string( translations[ option ].keys() )
                sys.exit( 1 )
        string = string[:match.start()] + value + string[match.end():]
    return string

def parse_dictionary ( strings ) :
    dictionary = dict()
    for string in strings :
        key_value = re.split( '=', string )
        if len( key_value ) != 2 :
            print "Error: Invalid key=value pair (" + string + ")."
            sys.exit( 1 )
        dictionary[ key_value[ 0 ] ] = key_value[ 1 ]
    return dictionary

class GUI( Tkinter.Frame ) :
    def __init__( self, master, grid_defs ) :
        Tkinter.Frame.__init__( self, master )
        self.pack()
        self.grid_defs = grid_defs
        self.grid_list = Tkinter.Listbox( self, selectmode = Tkinter.SINGLE )
        self.grid_list.pack( side=Tkinter.LEFT )
        self.settings_frame = Tkinter.Frame( self )
        self.settings_frame.pack( side = Tkinter.LEFT )
        self.var_frame = Tkinter.Frame( self.settings_frame )
        self.var_frame.pack( side=Tkinter.TOP )
        Tkinter.Button( self.settings_frame, text = 'Ok', command = self.click_ok ).pack( side = Tkinter.BOTTOM )
        for grid in sorted( grid_defs.keys() ) :
            self.grid_list.insert( Tkinter.END, grid ) 
        self.grid_list.selection_set( 0 )
        self.select_grid( self.grid_list.get( 0 ) )
        self.after( 250, self.poll_grid_list )

    def click_ok( self ) :
        self.quit()

    def poll_grid_list( self ) :
        current = self.grid_list.get( self.grid_list.curselection()[ 0 ] )
        if current != self.selected_grid :
            self.select_grid( current )
        self.after( 250, self.poll_grid_list )

    def select_grid( self, grid ) :
        self.selected_grid = grid
        for child in self.var_frame.winfo_children() :
            child.destroy()

        defaults = dict()
        if "default" in grid_defs[ grid ] :
            defaults = parse_dictionary( grid_defs[ grid ][ "default" ] )

        i = 0
        self.values = dict()
        for var in variables( grid_defs[ grid ][ "type" ] ) :
            Tkinter.Label( self.var_frame, text = var ).grid( row=i, column=0 )
            self.values[ var ] = Tkinter.StringVar()
            Tkinter.Entry( self.var_frame, textvar=self.values[ var ] ).grid( row=i, column=1 )
            if var in defaults :
                self.values[ var ].set( defaults[ var ] )
            i += 1

    def parameters( self ) :
        parameters = dict()
        for var in self.values :
            parameters[ var ] = self.values[ var ].get()
        return parameters

argParser = argparse.ArgumentParser()
argParser.add_argument( '-I', '--include', help="include file 'INCLUDE' in grid definitions", action='append' )
argParser.add_argument( '-f', '--file', help="read settings from file 'FILE'" )
argParser.add_argument( '-o', '--output', help="write generated header to 'OUTPUT'" )
argParser.add_argument( '--dump', help="dump grid definitions", action='store_true' )
argParser.add_argument( '--list', help="list defined grids", action='store_true' )
argParser.add_argument( '--options', metavar='GRID', help="list options for grid 'GRID'" )
argParser.add_argument( '--grid', nargs='+', help="generate additional typedef for 'GRID'", action='append' )
argParser.add_argument( 'name', nargs='?', help="Alias for the grid to select" )
argParser.add_argument( 'parameter', nargs='*' )
args = argParser.parse_args()

grid_defs = dict()
if 'DUNE_GRID_SELECT_INCLUDE' in os.environ :
    for defs in re.split( ' +', os.environ[ 'DUNE_GRID_SELECT_INCLUDE' ] ) :
        grid_defs.update( json.load( open( defs, 'r' ) ) )
if args.include :
    for defs in args.include :
        grid_defs.update( json.load( open( defs, 'r' ) ) )
if len( grid_defs.keys() ) == 0 :
    print "Error: No grid definitions found."
    sys.exit( 1 )

grids = []
if args.dump :
    grid_data = []
    for grid in grid_defs :
        grid_data += [ grid_defs[ grid ] ]
    print json.dumps( grid_defs, indent = 2 )
    sys.exit( 0 )
elif args.list :
    print "Available grid definitions:"
    for grid in sorted( grid_defs.keys() ) :
        print " - " + grid
    sys.exit( 0 )
elif args.options:
    print "Available options for " + args.options + ":"
    defaults = dict()
    if "default" in grid_defs[ args.options ] :
        defaults = parse_dictionary( grid_defs[ args.options ][ "default" ] )
    for var in variables( grid_defs[ args.options ][ "type" ] ) :
        if var in defaults :
            print " - " + var + " (default: " + defaults[ var ] + ")"
        else :
            print " - " + var
    sys.exit( 0 )
elif args.file :
    if args.name :
        print "Error: Cannot read grid from command line when using '--file'."
        sys.exit( 1 )
    data = json.load( open( args.file, 'r' ) )
    if type( data ) is dict :
        if not "name" in data :
            data[ "name" ] = "GridType"
        if "parameters" in data :
            grids += [ (data[ "name" ], data[ "grid" ], parse_dictionary( data[ "parameters" ] )) ]
        else :
            grids += [ (data[ "name" ], data[ "grid" ], dict()) ]
    elif type( data ) is list :
        for grid in data :
            if "parameters" in grid :
                grids += [ (grid[ "name" ], grid[ "grid" ], parse_dictionary( grid[ "parameters" ] )) ]
            else :
                grids += [ (grid[ "name" ], grid[ "grid" ], dict()) ]
    else :
        print "Error: Invalid top-level entry in '" + args.file + "'."
        sys.exit( 1 )
elif args.name or args.grid :
    if args.grid :
        for grid in args.grid :
            grid_name = grid.pop( 0 )
            if len( grid ) < 1 :
                print "Error: Missing defintion for grid type '" + grid_name + "'."
            grid_alias = grid.pop( 0 )
            grids += [ (grid_name, grid_alias, parse_dictionary( grid )) ]
    if args.name :
        grids += [ ("GridType", args.name, parse_dictionary( args.parameter )) ]

else :
    root = Tkinter.Tk()
    gui = GUI( root, grid_defs )
    gui.mainloop()
    grids += [ ("GridType", gui.selected_grid, gui.parameters()) ]
    root.destroy()

typedefs = []
includes = set()
for name, alias, parameters in grids :
    if not alias in grid_defs :
        print "Error: Cannot find definition for '" + alias + "' in definition of '" + name + "'."
        sys.exit( 1 )
    grid_data = grid_defs[ alias ]

    defaults = dict()
    if "default" in grid_data :
        defaults = parse_dictionary( grid_data[ "default" ] )

    translations = dict()
    if "translate" in grid_data :
        for option in grid_data[ "translate" ] :
            translations[ option ] = parse_dictionary( grid_data[ "translate" ][ option ] )

    typedefs += [ (name, replace( grid_data[ "type" ], parameters, defaults, translations )) ]
    for include in grid_data[ "include" ] :
        includes.add( include )

if args.output :
    out = open( args.output, 'w' )
    print >> out, "/* This file was autogenerated by dune-grid-select -- do not modify it. */"
    print >> out
else :
    out = sys.stdout

print >> out, "#ifndef DUNE_GRID_SELECTOR_HH"
print >> out, "#define DUNE_GRID_SELECTOR_HH"

print >> out
for include in includes :
    print >> out, "#include <" + include + ">"

print >> out
print >> out, "namespace Dune"
print >> out, "{"

print >> out
print >> out, "  namespace GridSelector"
print >> out, "  {"

for grid_name, grid_type in typedefs :
    print >> out
    print >> out, "    typedef " + grid_type + " " + grid_name + ";"

print >> out
print >> out, "  } // namespace GridSelector"

print >> out
print >> out, "} // namespace Dune"

print >> out
print >> out, "#endif // #ifndef DUNE_GRID_SELECTOR_HH"
